= Back to the future: How a 2004 book helps us design cloud native software
Konrad Renner <github.com/konradrenner>
2022-08-29
:revnumber: {project-version}
:example-caption!:
ifndef::imagesdir[:imagesdir: images]
ifndef::sourcedir[:sourcedir: ../../main/java]

== Domain Driven Design

image::ddd.jpg[]

== Introduction

[%step]
* Speaker of the day: *Konrad Renner*
* Day to day job: *Software Architect at ARZ Allgemeines Rechenzentrum GmbH*
* Some personal things: *Linux / Java / DDD / Open Source / OpenHab / Star Wars / BBQ* enthusiast
* Direct link to digital life: *link:github.com/konradrenner[GitHub - konradrenner]*

== Agenda

[%step]
* What is it about?
* How can this time travel help us?
* Are there other crazy ideas Doc?
* Sounds pretty heavy. How does this all come together?
* Let me know what you think about all this

== What is it about?

[%step]
* Ubiquitous Language
* Distillation and Context
* Refactoring toward deeper insight

// Press the `*s*` key to access speaker notes.
[NOTE.speaker]
--
* *Ubiquitous Language most important part*
** Hard to define und extract, much work is needed
** It always has a Context where it is "valid"
** Example: Doc Browns DeLorean DMC-12
*** When Doc Brown talks about a timemachine, he means his DMC-12
*** When a mechanic gets his fingers on the DMC-12, he is repairing a car
* *Distillation and Context*
** You can think about Problem space and Solution Space
** _Distillation_: Distill the core domain out of your business domain
** Put most of your effort in your core domain
** _Context_: The area in which a word or some kind of "structure" has the same meaning everywhere
** Example: Doc Browns DeLorean DMC-12
*** Core Domain is the timetravel functionality
*** Subdomain is, that the DeLorean is possible to drive
*** Both need energy to function
**** In case of the driving functionality there just has to be any engine
**** But in case of the timetravel functionality there must be an atomic reactor
**** So in one case, the solution is "any engine" and in the other case it is "atomic reactor"
* *Refactoring toward deeper insight*
** Design and implementation is an ongoing process
** Agile and DDD are a perfect match
--

=== Strategic and Tactical Design

image::ddd_overview.png[scaledwidth=100%]

// Press the `*s*` key to access speaker notes.
[NOTE.speaker]
--
* Strategic Design
** "Big Picture"
** Communication paths betweens contexts
* Tactical Design
** Model within a Bounded Context
* _Examples for technical communication discusions will come in the next slides!_
--

== How can this time travel help us?

image::tragedy.jpg[]

// Press the `*s*` key to access speaker notes.
[NOTE.speaker]
--
* There is a tragedy that not only concerns Marty McFly and Doc Brown, but also a galaxy far, far away
* The cut of Microservices can be a tragedy if you take an inappropriate approach
* inappropriate approaches would be
** pure technical
** based on organizational circumstances
* Why can they end in a tragedy?
** Because inappropriate cut Microservices can lead to unnecessary remote communication
** In the worst case you transform a build- and runtime monolithic app with local transactions, to a runtime monolithic app with distributed transactions
*** Sooner or later this will lead to a real resilience tragedy
* Service Mesh and similar solutions are often only symptom treatments, but do not solve the problems at the cause
* So this "time travel" to the 2004 book, can help us find more effective approach
** As the book subtitle states: Tackling complexity in the heart of software
** In the next couple of slides I will show you some of the concepts, to minimize the propability that such tragedies will occur
--

=== DDD for "cloud native software architecture"

[%step]
* Focus on your core domain, not technical aspects
* Establish a common understanding of strategic AND tactical design
** Merge the people, split the software
* Build Microservices/Self-Contained-Systems based on Bounded Context
** Maybe a Bounded Context can also help by defining K8s Namespaces ;-)

// Press the `*s*` key to access speaker notes.
[NOTE.speaker]
--
* One of the most common questions in my day to day work is, how to size Microservices or siblings (e.g. SCS)
** Just use the Bounded Contexts
* The Context Map helps to understand how communication flows through the system
** The relationship types helps in discusions about the technical communication
*** Shared Kernel: Create a library
*** Open Host Service: Maybe RESTful with OpenAPI powered Published Language
--

=== Strategic Design

[plantuml,bounded-context]
----
skinparam componentStyle rectangle

title Back to the future - Context Map

cloud "Car Context" {
  [Engine]
  [Car]
  
  () ACL as timemachine_acl
  
  Car - Engine
  timemachine_acl- Car
}

cloud "Timemachine Context" {
  [Timemachine]
  [Inventor]
  [Driver]
  [Flux Capacitor] as flux
  
  Timemachine -up- Inventor
  Timemachine -up- Driver
  Timemachine --up- flux
  
  Timemachine --> timemachine_acl : Open Host Service
}

cloud "Terrorist Context" {
  [Betrayer]
  [Terrorist]
  
  () ACL as betrayer_acl
  
  Betrayer- Terrorist
  betrayer_acl - Betrayer
  
  betrayer_acl <-- Inventor : Confirmist
}

legend bottom
  |= |= Description |
  | -> | Arrow points from Upstream to Downstream|
  | ACL | Anti-Corruption-Layer|
endlegend
----

== Are there other crazy ideas Doc?

[%step]
* _Disclaimer:_ The following tooling are just my personal favorites
* Start with link:https://www.eventstorming.com/[Event Storming]
* Document architecture with link:https://arc42.org/overview[arc42 template]
* Take out the pain of documentation with link:https://docs-as-co.de/[Documentation As Code]
* Structure code on basis of link:https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html[Clean Architecture]


=== Event Storming

image::event_storming.png[]

// Press the `*s*` key to access speaker notes.
[NOTE.speaker]
--
* The key idea of EventStorming is
. See the system as a whole 
. Find a problem worth solving (Distillation)
. Gather the best immediately available information
. Start implementing a solution from the best possible starting point (Context)
* What you see here is just the first step in a "Big Picture" workshop
* Key idea is, to have all relevant stakeholder in one room
** They put their view in brain storming fashion on an "endless" wall, in form of events
** Events are always past tense
** They discuss the outcomes
*** Consensus is not required, it could be a signal for different meanings of an event; mark heavy discussion with a hotspot sticky
* Next iteration step would be integration of people and external systems on the wall
* Then you can start modelling your processes with the integration of commands, policies and read models
** Picture that explain (nearly) everthing
--

=== Event Storming

image::event_storming_2.png[]

// Press the `*s*` key to access speaker notes.
[NOTE.speaker]
--
* Yellow: People
* Blue: Command
* Orange: Event
* Purple: Policy
* Green: Read Model
* Pink: External System
--

=== Clean Architecture

image::CleanArchitecture.jpeg[]

// Press the `*s*` key to access speaker notes.
[NOTE.speaker]
--
* The most important part is flow of control
** Never ever make inner circles depend on outer!
** Technical aspects must never enter the domain logic
*** If so: your code will e.g. not be unit testable (you cannot mock away technical aspects sufficient)
* This architecture perfectly fits with the "Layered Architecture" as described in the DDD book
* An example is just 2 slides away
--

== Sounds pretty heavy. How does this all come together?

[%step]
* link:https://github.com/konradrenner/stammdaten/blob/master/README.adoc[publishing-company example]
* Uses link:https://quarkus.io/[Quarkus] as _"Kubernetes native Java stack"_
* Boundary-Control-Entity approach for implementing Clean Architecture on top of DDD
* Architecture automatically checked with link:https://www.archunit.org/[ArchUnit]
* arc42 published via maven site plugin

// Press the `*s*` key to access speaker notes.
[NOTE.speaker]
--
* Some think, Java is not the cool or hip enough nowadays
** They did not try Quarkus yet
** rock solid tooling, massive community, native performance and state of the art dev experience
* DDD and Clean Architecture are a perfect match
** Use BCE and you also get a standardized und clear structuring of your projects
* Let the tooling do the "boring" work for you
** Automatic versioning and releasing
** Automatic publishing
** Automatic testing
* Single source of truth for all aspects
** Architecture, Security, Code, Config
** Every change is tracked in your favorite VCS and absolutly traceable
** Maybe you use GitOps to further improve automation
--

=== Time for an example

image::code.jpg[]

// Press the `*s*` key to access speaker notes.
[NOTE.speaker]
--
* Disclaimer: The link:https://github.com/konradrenner/stammdaten/blob/master/README.adoc[publishing-company example] has just little todo with back to the future :-) (one book entry)
* This example "lives", so it is in parts unfinished an will change from time to time
* It demonstrates all of the tools discussed, except context mapping
** It just contains the "Author Aggregate" from the "Author Context" (1:1 mapping)
* It consists of an Web UI (JSF), REST API and an Cross Compiled Mobile/Desktop Companion App
--

== But...

[%step]
* _Organizations which design systems […] are constrained to produce designs which are copies of the communication structures of these organizations._ - Melvin E. Conway
* Have a look at link:https://teamtopologies.com/[Team Topologies]
** Approach to modern software delivery with awareness of
*** Conway’s Law, team cognitive load and responsive organization evolution

=== Team Topologies

image::team-topologies.png[]

// Press the `*s*` key to access speaker notes.
[NOTE.speaker]
--
* Like DDD it "just" formalizes some good practices and ideas
--

== Let me know what you think about all this

image::force.jpg[]

// Press the `*s*` key to access speaker notes.
[NOTE.speaker]
--
* Thank you for the possibilty to share my thoughts on this topic
* In closing, I have only two things to say
** Never stop refactoring, there is no "perfect" or "everlasting" solution
** Software development is a learning process, working code is a nice side effect
** And may the force be with you :-)
--

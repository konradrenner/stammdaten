= Back to the future: How a 2004 book helps us design cloud native software
Konrad Renner <github.com/konradrenner>
2022-08-29
:revnumber: {project-version}
:example-caption!:
ifndef::imagesdir[:imagesdir: images]
ifndef::sourcedir[:sourcedir: ../../main/java]

== Domain Driven Design

image::ddd.jpg[]

== Introduction

[%step]
* Speaker of the day: *Konrad Renner*
* Day to day job: *Software Architect at ARZ Allgemeines Rechenzentrum GmbH*
* Some personal things: *Linux / Java / DDD / Open Source / OpenHab / Star Wars / BBQ* enthusiast
* Direct link to digital life: *link:github.com/konradrenner[GitHub - konradrenner]*

== Agenda

[%step]
* What is it about?
* How can this time travel help us?
* Are there other crazy ideas Doc?
* Sounds pretty heavy. How does this all come together?
* Let me know what you think about all this

== What is it about?

[%step]
* Ubiquitous Language
* Distillation and Context
* Refactoring toward deeper insight

// Press the `*s*` key to access speaker notes.
[NOTE.speaker]
--
* *Ubiquitous Language most important part*
** Hard to define und extract, much work is needed
** It always has a Context where it is "valid"
** Example: Doc Browns DeLorean DMC-12
*** When Doc Brown talks about a timemachine, he means his DMC-12
*** When a mechanic gets his fingers on the DMC-12, he is repairing a car
* *Distillation and Context*
** You can think about Problem space and Solution Space
** _Distillation_: Distill the core domain out of your business domain
** Put most of your effort in your core domain
** _Context_: The area in which a word or some kind of "structure" has the same meaning everywhere
** Example: Doc Browns DeLorean DMC-12
*** Core Domain is the timetravel functionality
*** Subdomain is, that the DeLorean is possible to drive
*** Both need energy to function
**** In case of the driving functionality there just has to be any engine
**** But in case of the timetravel functionality there must be an atomic reactor
**** So in one case, the solution is "any engine" and in the other case it is "atomic reactor"
* *Refactoring toward deeper insight*
** Design and implementation is an ongoing process
** Agile and DDD are a perfect match
--

=== Strategic and Tactical Design

image::ddd_overview.png[scaledwidth=100%]

// Press the `*s*` key to access speaker notes.
[NOTE.speaker]
--
* Strategic Design
** "Big Picture"
** Communication paths betweens contexts
* Tactical Design
** Model within a Bounded Context
* _Examples for technical communication discusions will come in the next slides!_
--

== How can this time travel help us?

image::tragedy.jpg[]

// Press the `*s*` key to access speaker notes.
[NOTE.speaker]
--
* There is a tragedy that not only concerns Marty McFly and Doc Brown, but also a galaxy far, far away
* The cut of Microservices can be a tragedy if you take an inappropriate approach
* inappropriate approaches would be
** pure technical
** based on organizational circumstances
* Why can they end in a tragedy?
** Because inappropriate cut Microservices can lead to unnecessary remote communication
** In the worst case you transform a build- and runtime monolithic app with local transactions, to a runtime monolithic app with distributed transactions
*** Sooner or later this will lead to a real resilience tragedy
* Service Mesh and similar solutions are often only symptom treatments, but do not solve the problems at the cause
* So this "time travel" to the 2004 book, can help us find more effective approach
** As the book subtitle states: Tackling complexity in the heart of software
** In the next couple of slides I will show you some of the concepts, to minimize the propability that such tragedies will occur
--

=== DDD for "cloud native software architecture"

[%step]
* Focus on your core domain, not technical aspects
* Establish a common understanding of strategic AND tactical design
** Merge the people, split the software
* Build Microservices/Self-Contained-Systems based on Bounded Context
** Maybe a Bounded Context can also help by defining K8s Namespaces ;-)

// Press the `*s*` key to access speaker notes.
[NOTE.speaker]
--
* One of the most common questions in my day to day work is, how to size Microservices or siblings (e.g. SCS)
** Just use the Bounded Contexts
* The Context Map helps to understand how communication flows through the system
** The relationship types helps in discusions about the technical communication
*** Shared Kernel: Create a library
*** Open Host Service: Maybe RESTful with OpenAPI powered Published Language
--

=== Strategic Design - Context Map

image::bc.jpeg[]

=== Tactical Design - Aggregate

image::domain-ueberblick.png[]

== Are there other crazy ideas Doc?

[%step]
* _Disclaimer:_ The following tooling are just my personal favorites
* Start with link:https://www.eventstorming.com/[Event Storming]
* Document architecture with link:https://arc42.org/overview[arc42 template]
* Take out the pain of documentation with link:https://docs-as-co.de/[Documentation As Code]
* Structure code on basis of link:https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html[Clean Architecture]


=== Event Storming

image::event_storming.png[]

=== Clean Architecture

image::CleanArchitecture.jpeg[]

== Sounds pretty heavy. How does this all come together?

[%step]
* link:https://github.com/konradrenner/stammdaten/blob/master/README.adoc[publishing-company example]
* Uses link:https://quarkus.io/[Quarkus] as _"Kubernetes native Java stack"_
* Boundary-Control-Entity approach for implementing Clean Architecture on top of DDD
* Architecture automatically checked with link:https://www.archunit.org/[ArchUnit]
* arc42 published via maven site plugin

// Press the `*s*` key to access speaker notes.
[NOTE.speaker]
--
* Some think, Java is not the cool or hip enough nowadays
** They did not try Quarkus yet
** rock solid tooling, massive community, native performance and state of the art dev experience
* DDD and Clean Architecture are a perfect match
** Use BCE and you also get a standardized und clear structuring of your projects
* Let the tooling do the "boring" work for you
** Automatic versioning and releasing
** Automatic publishing
** Automatic testing
* Single source of truth for all aspects
** Architecture, Security, Code, Config
** Every change is tracked in your favorite VCS and absolutly traceable
** Maybe you use GitOps to further improve automation
--

=== Time for an example

image::code.jpg[]

== But...

[%step]
* _Organizations which design systems […] are constrained to produce designs which are copies of the communication structures of these organizations._ - Melvin E. Conway
* Have a look at link:https://teamtopologies.com/[Team Topologies]
** Approach to modern software delivery with awareness of
*** Conway’s Law, team cognitive load and responsive organization evolution

=== Team Topologies

image::team-topologies.png[]

// Press the `*s*` key to access speaker notes.
[NOTE.speaker]
--
* Like DDD it "just" formalizes some good practices and ideas
--

== Let me know what you think about all this

image::force.jpg[]

// Press the `*s*` key to access speaker notes.
[NOTE.speaker]
--
* Thank you for the possibilty to share my thoughts on this topic
* In closing, I have only two things to say
** Never stop refactoring, there is no "perfect" or "everlasting" solution
** And may the force be with you :-)
--
